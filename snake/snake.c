#include <stdio.h>#include <stdlib.h>#include <string.h>#define W_WIDTH 450#define W_HEIGHT 350#define kBlockSize 16typedef struct{    short x, y;} Point2D;typedef struct{    Point2D * blocks;    int capacity;    short length;    short direction; // 0 = up, 1 = right, 2 = down, 3 = left} Snake;WindowPtr gMainWindow;Boolean gGameOver = false;Snake gSnake;Point2D gFood;void InitializeMacintosh();WindowPtr CreateMainWindow();void QuitGame();void MainLoop();void HandleMouseDown(EventRecord * event);void HandleKeyDown(EventRecord * event);void HandleUpdate(WindowPtr window);void GetDirection(EventRecord * event);void RealocateSnake();Boolean CheckCollision(Point2D * pt);void GenerateFood();void InitializeGame();void UpdateGame();void DrawGame();void DrawBlock(Point2D * pt, Pattern * pattern);void DrawScore(int score);int main(void){    int i = 0;    // menu bar    Handle menuBarHandle;    // apple menu    MenuHandle appleMenu;    // initialize toolbox    InitializeMacintosh();        // window    CreateMainWindow();        menuBarHandle = GetNewMBar(128);    SetMenuBar(menuBarHandle);        appleMenu = GetMenuHandle(128);    AppendResMenu(appleMenu, 'DRVR');    DrawMenuBar();    while(true){        //game init        InitializeGame();        MainLoop();        free(gSnake.blocks);        gGameOver = false;    }    return 0;}void InitializeMacintosh(){    InitGraf(&qd.thePort);    InitFonts();    InitWindows();    TEInit();    InitDialogs(NULL);    InitCursor();}WindowPtr CreateMainWindow(){    gMainWindow = GetNewWindow(128, nil, (WindowPtr)-1L);    ShowWindow(gMainWindow);    SizeWindow(gMainWindow, W_WIDTH, W_HEIGHT, true);    return gMainWindow;}void QuitGame(){    // free snake memory    free(gSnake.blocks);    ExitToShell();}void RealocateSnake(){    gSnake.capacity = gSnake.capacity + 10;    gSnake.blocks = (Point2D *) realloc(gSnake.blocks, gSnake.capacity*sizeof(Point2D));}void MainLoop(){    EventRecord event;    while(!gGameOver){        //taking events        if (GetNextEvent(everyEvent, &event)){            switch(event.what){                case mouseDown:                    HandleMouseDown(& event);                    break;                                case mouseUp:                    break;                case keyDown:                case autoKey:                    HandleKeyDown(& event);                    GetDirection(& event);                    break;                                case updateEvt:                    HandleUpdate((WindowPtr)event.message);                    break;                case nullEvent:                    break;                default:                    break;            }        }        UpdateGame();        DrawGame();        Delay(5, NULL);    }    SetPort(gMainWindow);    EraseRect(&gMainWindow->portRect);    MoveTo(W_HEIGHT/2, W_WIDTH/2);    DrawString("\pGame Over");    Delay(120,NULL);}void HandleMouseDown(EventRecord * event){    WindowPtr window;    long menuAndItem;    short theMenu;    short theMenuItem;    short part;    Handle menuBarHandle;    MenuHandle appleMenu;    Str255 itemName;    menuBarHandle = GetNewMBar(128);    appleMenu = GetMenuHandle(128);    part = FindWindow(event->where, &window);    switch (part){        case inDrag:            DragWindow(window, event->where, &qd.screenBits.bounds);            break;        case inGoAway:            DisposeWindow(window);            QuitGame();            break;        case inContent:            //             break;        case inMenuBar:            menuAndItem = MenuSelect(event->where);            if (menuAndItem > 0){                theMenu = HiWord(menuAndItem);                theMenuItem = LoWord(menuAndItem);                switch(theMenu){                    case 128:                        switch(theMenuItem){                            case 1:                                SysBeep(1);                                break;                            default:                                GetMenuItemText(appleMenu, theMenuItem, itemName);                                OpenDeskAcc(itemName);                                break;                        }                        break;                    case 129:                        switch(theMenuItem){                            case 1:                                SysBeep(1);                                break;                            case 2:                                QuitGame();                                break;                        }                        break;                }            }            HiliteMenu(0);            break;    }}void HandleUpdate(WindowPtr window){    BeginUpdate(window);    EndUpdate(window);}void HandleKeyDown(EventRecord * event){    char key;    int  modifiers;    key = event->message & charCodeMask;    modifiers = event->modifiers;        if (modifiers & cmdKey){        if (key =='q' || key == 'Q'){            QuitGame();        }    }    }void GetDirection(EventRecord * event){    char key;    key = event->message & charCodeMask;    switch(key){        case kUpArrowCharCode:            if (gSnake.direction != 2 ) gSnake.direction = 0;            break;        case kRightArrowCharCode:            if (gSnake.direction != 3 ) gSnake.direction = 1;            break;        case kDownArrowCharCode:            if (gSnake.direction != 0 ) gSnake.direction = 2;            break;        case kLeftArrowCharCode:            if (gSnake.direction != 1 ) gSnake.direction = 3;            break;    }}// game logicvoid InitializeGame(){    short i;    gSnake.length = 5;    gSnake.capacity = 10;    gSnake.direction = 1;    gSnake.blocks = (Point2D *) malloc(gSnake.capacity * sizeof(Point2D));    for (i = 0; i < gSnake.length; i++){        gSnake.blocks[i].x = 10 - i;        gSnake.blocks[i].y = 10;    }    GenerateFood();}Boolean CheckCollision(Point2D * pt){    int i;    for (i = 0; i < gSnake.length; i++){        if (gSnake.blocks[i].x == pt->x && gSnake.blocks[i].y == pt->y ){            return true;        }    }    return false;}void GenerateFood(){    do {        gFood.x = abs(Random()) % 20;        gFood.y = abs(Random()) % 20;    } while(CheckCollision(&gFood));}void UpdateGame(){    int i;    Point2D nextHead = gSnake.blocks[0];    switch(gSnake.direction){        case 0: nextHead.y--; break;        case 1: nextHead.x++; break;        case 2: nextHead.y++; break;        case 3: nextHead.x--; break;    }    // colision walls    if (nextHead.x<0 || nextHead.x > W_WIDTH/kBlockSize || nextHead.y < 0 || nextHead.y>W_HEIGHT/kBlockSize){        gGameOver = true;        return;    }    // colision body    if (CheckCollision(&nextHead)){        gGameOver = true;        return;    }    //food eaten    if (nextHead.x == gFood.x && nextHead.y == gFood.y){        if (gSnake.length < gSnake.capacity){            gSnake.length++;        }        //realocate        if (gSnake.capacity == gSnake.length){            RealocateSnake();            gSnake.length++;        }        GenerateFood();    }    // Move    for(i = gSnake.length-1; i>0;i--){        gSnake.blocks[i] = gSnake.blocks[i-1];    }    gSnake.blocks[0] = nextHead;    }// game drawingvoid DrawBlock(Point2D * pt, Pattern * pattern){     Rect r;    r.left = pt->x * kBlockSize;    r.top = pt->y * kBlockSize;    r.right = r.left + kBlockSize;    r.bottom = r.top + kBlockSize;    FillRect(&r,pattern );}void DrawGame(){    int i;    SetPort(gMainWindow);    EraseRect(&gMainWindow->portRect);    //draw snake    for(i = 0; i < gSnake.length; i ++ ){        DrawBlock(&gSnake.blocks[i], &qd.black);    }    //draw food    DrawBlock(&gFood, &qd.gray);    //draw score    DrawScore(gSnake.length - 5);}void DrawScore(int score){    Str255 scoreStr;    sprintf((char*)scoreStr+1, "%d", score);    scoreStr[0] = strlen((char*)scoreStr+1);    MoveTo(20,20);    DrawString(scoreStr);}